.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::BaseCalc 3"
.TH Math::BaseCalc 3 "2022-04-11" "perl v5.34.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::BaseCalc \- Convert numbers between various bases
.SH "VERSION"
.IX Header "VERSION"
version 1.019
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Math::BaseCalc;
\&
\&  my $calc = new Math::BaseCalc(digits => [0,1]); #Binary
\&  my $bin_string = $calc\->to_base(465); # Convert 465 to binary
\&
\&  $calc\->digits(\*(Aqoct\*(Aq); # Octal
\&  my $number = $calc\->from_base(\*(Aq1574\*(Aq); # Convert octal 1574 to decimal
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module facilitates the conversion of numbers between various
number bases.  You may define your own digit sets, or use any of
several predefined digit sets.
.PP
The \fBto_base()\fR and \fBfrom_base()\fR methods convert between Perl numbers and
strings which represent these numbers in other bases.  For instance,
if you're using the binary digit set [0,1], \f(CW$calc\fR\->\fBto_base\fR\|(5) will
return the string \*(L"101\*(R".  \f(CW$calc\fR\->from_base(\*(L"101\*(R") will return the
number 5.
.PP
To convert between, say, base 7 and base 36, use the 2\-step process
of first converting to a Perl number, then to the desired base for the
result:
.PP
.Vb 2
\& $calc7  = new Math::BaseCalc(digits=>[0..6]);
\& $calc36 = new Math::BaseCalc(digits=>[0..9,\*(Aqa\*(Aq..\*(Aqz\*(Aq]);
\&
\& $in_base_36 = $calc36\->to_base( $calc7\->from_base(\*(Aq3506\*(Aq) );
.Ve
.PP
If you just need to handle regular octal & hexdecimal strings, you
probably don't need this module.  See the \fBsprintf()\fR, \fBoct()\fR, and \fBhex()\fR
Perl functions.
.SH "METHODS"
.IX Header "METHODS"
.IP "\(bu" 4
new Math::BaseCalc
.IP "\(bu" 4
new Math::BaseCalc(digits=>...)
.Sp
Create a new base calculator.  You may specify the digit set to use,
by either giving the digits in a list reference (in increasing order,
with the 'zero' character first in the list) or by specifying the name
of one of the predefined digit sets (see the \fBdigit()\fR method below).
.Sp
If your digit set includes the character \f(CW\*(C`\-\*(C'\fR, then a dash at the
beginning of a number will no longer signify a negative number.
.IP "\(bu" 4
\&\f(CW$calc\fR\->to_base(\s-1NUMBER\s0)
.Sp
Converts a number to a string representing that number in the
associated base.
.Sp
If \f(CW\*(C`NUMBER\*(C'\fR is a \f(CW\*(C`Math::BigInt\*(C'\fR object, \f(CW\*(C`to_base()\*(C'\fR will still work
fine and give you an exact result string.
.IP "\(bu" 4
\&\f(CW$calc\fR\->from_base(\s-1STRING\s0)
.Sp
Converts a string representing a number in the associated base to a
Perl integer.  The behavior when fed strings with characters not in
\&\f(CW$calc\fR's digit set is currently undefined.
.Sp
If \f(CW\*(C`STRING\*(C'\fR converts to a number too large for perl's integer
representation, beware that the result may be auto-converted to a
floating-point representation and thus only be an approximation.
.IP "\(bu" 4
\&\f(CW$calc\fR\->digits
.IP "\(bu" 4
\&\f(CW$calc\fR\->digits(...)
.Sp
Get/set the current digit set of the calculator.  With no arguments,
simply returns a list of the characters that make up the current digit
set.  To change the current digit set, pass a list reference
containing the new digits, or the name of a predefined digit set.
Currently the predefined digit sets are:
.Sp
.Vb 6
\&       bin => [0,1],
\&       hex => [0..9,\*(Aqa\*(Aq..\*(Aqf\*(Aq],
\&       HEX => [0..9,\*(AqA\*(Aq..\*(AqF\*(Aq],
\&       oct => [0..7],
\&       64  => [\*(AqA\*(Aq..\*(AqZ\*(Aq,\*(Aqa\*(Aq..\*(Aqz\*(Aq,0..9,\*(Aq+\*(Aq,\*(Aq/\*(Aq],
\&       62  => [0..9,\*(Aqa\*(Aq..\*(Aqz\*(Aq,\*(AqA\*(Aq..\*(AqZ\*(Aq],
\&
\& Examples:
\&  $calc\->digits(\*(Aqbin\*(Aq);
\&  $calc\->digits([0..7]);
\&  $calc\->digits([qw(w a l d o)]);
.Ve
.Sp
If any of your \*(L"digits\*(R" has more than one character, the behavior is
currently undefined.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ken Williams, kwilliams@cpan.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This is free software in the colloquial nice-guy sense of the word.
Copyright (c) 1999, Ken Williams.  You may redistribute and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBperl\fR\|(1).
