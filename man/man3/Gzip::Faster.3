.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Gzip::Faster 3"
.TH Gzip::Faster 3 "2017-12-29" "perl v5.34.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Gzip::Faster \- simple and fast gzip and gunzip
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&    # Make a random input string
\&    my $input = join \*(Aq\*(Aq, map {int (rand (10))} 0..0x1000;
\&    use Gzip::Faster;
\&    # Compress the random string.
\&    my $gzipped = gzip ($input);
\&    # Uncompress it again.
\&    my $roundtrip = gunzip ($gzipped);
\&    # Put it into a file.
\&    gzip_to_file ($input, \*(Aqfile.gz\*(Aq);
\&    # Retrieve it again from the file.
\&    $roundtrip = gunzip_file (\*(Aqfile.gz\*(Aq);
.Ve
.SH "VERSION"
.IX Header "VERSION"
This documents version 0.21 of Gzip::Faster
corresponding to git commit 0b018b1a4df5f509a16c4262936b601382b6c3d6 <https://github.com/benkasminbullock/gzip-faster/commit/0b018b1a4df5f509a16c4262936b601382b6c3d6> made on Fri Dec 29 10:54:29 2017 +0900.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module compresses to and decompresses from the gzip and related
formats. See \*(L"About gzip\*(R" if you aren't familiar with the gzip
format.
.PP
The basic functions of the module are \*(L"gzip\*(R" and \*(L"gunzip\*(R", which
convert scalars to and from gzip format. There are also three
convenience functions built on these two: \*(L"gzip_file\*(R" reads a file
then compresses it; \*(L"gunzip_file\*(R" reads a file then uncompresses it;
and \*(L"gzip_to_file\*(R" compresses a scalar and writes it to a file.
.PP
Further to this, \*(L"deflate\*(R" and \*(L"inflate\*(R" work with the \*(L"deflate
format\*(R", which is the same as the gzip format except it has no header
information. \*(L"deflate_raw\*(R" and \*(L"inflate_raw\*(R" work with the
bare-bones version of this format without checksums.
.PP
If you need to control the compression beyond what is offered by
\&\*(L"gzip\*(R" and \*(L"gunzip\*(R", create a Gzip::Faster object using \*(L"new\*(R",
and compress and uncompress using the \*(L"zip\*(R" and \*(L"unzip\*(R"
methods. The type of compression can be toggled with \*(L"gzip_format\*(R"
and \*(L"raw\*(R". A file name can be set and retrieved from the gzip header
with \*(L"file_name\*(R", and the modification time of the file can be set
and retrieved with \*(L"mod_time\*(R". The level of compression can be
altered with \*(L"level\*(R". Perl flags can be copied into the gzip header
using \*(L"copy_perl_flags\*(R".
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "gzip"
.IX Subsection "gzip"
.Vb 1
\&    my $zipped = gzip ($plain);
.Ve
.PP
This compresses \f(CW$plain\fR into the gzip format. The return value is
the compressed version of \f(CW$plain\fR.
.SS "gunzip"
.IX Subsection "gunzip"
.Vb 1
\&    my $plain = gunzip ($zipped);
.Ve
.PP
This uncompresses \f(CW$zipped\fR and returns the result of the
uncompression. It prints a warning and returns the undefined value if
\&\f(CW$zipped\fR is the undefined value or an empty string. It throws a
fatal error if \f(CW$zipped\fR is not in the gzip format.
.SS "gzip_file"
.IX Subsection "gzip_file"
.Vb 1
\&    my $zipped = gzip_file (\*(Aqfile\*(Aq);
.Ve
.PP
This reads the contents of \fIfile\fR into memory and then runs \*(L"gzip\*(R"
on the file's contents. The return value and the possible errors are
the same as \*(L"gzip\*(R", plus this may also throw an error if \f(CW\*(C`open\*(C'\fR
fails.  To write a file name, use
.PP
.Vb 1
\&    my $zipped = gzip_file (\*(Aqfile\*(Aq, file_name => \*(Aqfile\*(Aq);
.Ve
.PP
The modification time can also be written:
.PP
.Vb 1
\&    my $zipped = gzip_file (\*(Aqfile\*(Aq, file_name => \*(Aqfile\*(Aq, mod_time => time ());
.Ve
.PP
\&\f(CW\*(C`gzip_file\*(C'\fR was added in version 0.04. File name writing was added in version
0.18. Modification time writing was added in version 0.19.
.SS "gunzip_file"
.IX Subsection "gunzip_file"
.Vb 1
\&    my $plain = gunzip_file (\*(Aqfile.gz\*(Aq);
.Ve
.PP
This reads the contents of \fIfile.gz\fR into memory and then runs
\&\*(L"gunzip\*(R" on the file's contents. The return value and the possible
errors are the same as \*(L"gunzip\*(R", plus this may also throw an error
if \f(CW\*(C`open\*(C'\fR fails. To retrieve a file name, use
.PP
.Vb 1
\&    my $plain = gunzip_file (\*(Aqfile.gz\*(Aq, file_name => \emy $file_name);
.Ve
.PP
Note that you must provide a scalar reference to the \f(CW\*(C`file_name\*(C'\fR
argument. This reference is filled in with the file name information
from the header of \fIfile.gz\fR. If \fIfile.gz\fR does not contain any file
name information, \f(CW$file_name\fR will contain the undefined value.
.PP
The modification time can also be read from the header:
.PP
.Vb 2
\&    my $plain = gunzip_file (\*(Aqfile.gz\*(Aq, file_name => \emy $file_name,
\&                             mod_time => \emy $mod_time);
.Ve
.PP
\&\f(CW\*(C`gunzip_file\*(C'\fR was added in version 0.04. File name reading was added in version
0.18. Modification time reading was added in version 0.19.
.SS "gzip_to_file"
.IX Subsection "gzip_to_file"
.Vb 1
\&    gzip_to_file ($plain, \*(Aqfile.gz\*(Aq);
.Ve
.PP
This compresses \f(CW$plain\fR in memory using \*(L"gzip\*(R" and writes the
compressed content to 'file.gz'. There is no return value. The errors
are the same as \*(L"gzip\*(R", plus this may also throw an error if \f(CW\*(C`open\*(C'\fR
fails. To write a file name, use
.PP
.Vb 1
\&    gzip_to_file ($plain, \*(Aqfile.gz\*(Aq, file_name => \*(Aqfile\*(Aq);
.Ve
.PP
\&\f(CW\*(C`gzip_to_file\*(C'\fR was added in version 0.08. File name writing was added in
version 0.18. Modification time writing was added in version 0.19.
.SS "deflate"
.IX Subsection "deflate"
.Vb 1
\&    my $deflated = deflate ($plain);
.Ve
.PP
This compresses \f(CW$plain\fR into the deflate format. The deflate format
is similar to the \*(L"gzip\*(R" format, except that it doesn't contain a
gzip header. The output of \f(CW\*(C`deflate\*(C'\fR can be inflated either with
\&\*(L"inflate\*(R" or with \*(L"gunzip\*(R".
.PP
To see an example of using \*(L"deflate\*(R" to write a \s-1PNG\s0 image file, see
\&\fIt/png.t\fR <https://fastapi.metacpan.org/source/BKB/Gzip-Faster-0.21/t/png.t> in the module's tests.
.PP
\&\f(CW\*(C`deflate\*(C'\fR was added in version 0.16.
.SS "inflate"
.IX Subsection "inflate"
.Vb 1
\&    my $inflated = inflate ($deflated);
.Ve
.PP
This inflates the output of \*(L"deflate\*(R". For all practical purposes
this is identical to \*(L"gunzip\*(R", and it's included only for
completeness. In other words, you can use inflate and gunzip
interchangeably.
.PP
\&\f(CW\*(C`inflate\*(C'\fR was added in version 0.16.
.SS "deflate_raw"
.IX Subsection "deflate_raw"
This is similar to \*(L"deflate\*(R", except that it doesn't write check sum
value in the data. The output is incompatible with \*(L"inflate\*(R" and
\&\*(L"gunzip\*(R", and must be inflated with \*(L"inflate_raw\*(R".
.PP
\&\f(CW\*(C`deflate_raw\*(C'\fR was added in version 0.16.
.SS "inflate_raw"
.IX Subsection "inflate_raw"
This inflates data output by \*(L"deflate_raw\*(R". It won't work on the
output of \*(L"gzip\*(R" and \*(L"deflate\*(R". It prints a warning and returns
the undefined value if its input is the undefined value or an empty
string. It throws a fatal error if its input is not in the deflate
format.
.PP
\&\f(CW\*(C`inflate_raw\*(C'\fR was added in version 0.16.
.SH "METHODS"
.IX Header "METHODS"
This section describes the object-oriented interface of Gzip::Faster.
.PP
If you need to control the compression beyond what is offered by
\&\*(L"gzip\*(R" and \*(L"gunzip\*(R", create a Gzip::Faster object using \*(L"new\*(R",
and compress and uncompress using the \*(L"zip\*(R" and \*(L"unzip\*(R"
methods. The type of compression can be toggled with \*(L"gzip_format\*(R"
and \*(L"raw\*(R". A file name can be set and retrieved from the gzip header
with \*(L"file_name\*(R", and the modification time of the file can be set
and retrieved with \*(L"mod_time\*(R". The level of compression can be
altered with \*(L"level\*(R". Perl flags can be copied into the gzip header
using \*(L"copy_perl_flags\*(R".
.SS "new"
.IX Subsection "new"
.Vb 1
\&    my $gf = Gzip::Faster\->new ();
.Ve
.PP
Create a Gzip::Faster object. The return value defaults to gzip
compression. This can be altered with \*(L"gzip_format\*(R" and \*(L"raw\*(R".
.PP
\&\f(CW\*(C`new\*(C'\fR was added in version 0.16.
.SS "zip"
.IX Subsection "zip"
.Vb 1
\&    my $zipped = $gf\->zip ($plain);
.Ve
.PP
Compress \f(CW$plain\fR. The type of compression can be set with \*(L"gzip\*(R"
and \*(L"raw\*(R".
.PP
\&\f(CW\*(C`zip\*(C'\fR was added in version 0.16.
.SS "unzip"
.IX Subsection "unzip"
.Vb 1
\&    my $plain = $gf\->unzip ($zipped);
.Ve
.PP
Uncompress \f(CW$zipped\fR. The type of uncompression can be set with
\&\*(L"gzip\*(R" and \*(L"raw\*(R".
.PP
\&\f(CW\*(C`unzip\*(C'\fR was added in version 0.16.
.SS "copy_perl_flags"
.IX Subsection "copy_perl_flags"
.Vb 1
\&    $gf\->copy_perl_flags (1);
.Ve
.PP
Copy some of the Perl flags (currently the utf8 flag) into the header
of the gzipped data.
.PP
Please see \*(L"Browser bugs and Gzip::Faster\*(R" for reasons why you might
not want to use this feature.
.PP
This feature of the module was restored in version 0.16.
.SS "file_name"
.IX Subsection "file_name"
.Vb 3
\&    my $filename = $gf\->file_name ();
\&    $gf\->file_name (\*(Aqthis.gz\*(Aq);
\&    my $zipped = $gf\->zip ($something);
.Ve
.PP
Get or set the file name in the compressed output. The file name is a
feature of the gzip format which is used, for example, when you use
the command \f(CW\*(C`gzip \-d file.gz\*(C'\fR. It tells \f(CW\*(C`gzip\*(C'\fR what to call the file
after it's uncompressed.
.PP
The file_name method is only useful for the gzip format, since the
deflate format does not have a header to store a name into. To prevent
accidental re-use of a file name, when you set a file name with
\&\*(L"file_name\*(R", then use \*(L"zip\*(R", the file name is deleted from the
object, so it needs to be set each time \*(L"zip\*(R" is called. If you set
a file name with \*(L"file_name\*(R" then call \*(L"unzip\*(R", that file name may
be deleted.
.PP
The following example demonstrates storing and then retrieving the
name:
.PP
.Vb 10
\&    use Gzip::Faster;
\&    my $gf = Gzip::Faster\->new ();
\&    $gf\->file_name ("blash.gz");
\&    my $something = $gf\->zip ("stuff");
\&    my $no = $gf\->file_name ();
\&    if ($no) {
\&        print "WHAT?\en";
\&    }
\&    else {
\&        print "The file name has been deleted by the call to zip.\en";
\&    }
\&    my $gf2 = Gzip::Faster\->new ();
\&    $gf2\->unzip ($something);
\&    my $file_name = $gf2\->file_name ();
\&    print "Got back file name $file_name\en";
.Ve
.PP
produces output
.PP
.Vb 2
\&    The file name has been deleted by the call to zip.
\&    Got back file name blash.gz
.Ve
.PP
(This example is included as \fIfile\-name.pl\fR <https://fastapi.metacpan.org/source/BKB/Gzip-Faster-0.21/examples/file-name.pl> in the distribution.)
.PP
The module currently has a hard-coded limit of 1024 bytes as the
maximum length of file name it can read back.
.PP
\&\f(CW\*(C`file_name\*(C'\fR was added in version 0.16.
.SS "gzip_format"
.IX Subsection "gzip_format"
.Vb 1
\&    $gf\->gzip_format (1);
.Ve
.PP
Switch the compression between the \*(L"gzip format\*(R" and the \*(L"deflate
format\*(R". A true value turns on the gzip format, and a false value
turns on the deflate format. The default is gzip format. Switching on
gzip format on an object automatically switches off \*(L"raw\*(R" format on
the object.
.PP
\&\f(CW\*(C`gzip_format\*(C'\fR was added in version 0.16.
.SS "raw"
.IX Subsection "raw"
.Vb 1
\&    $gf\->raw (1);
.Ve
.PP
Switch between the raw deflate and deflate formats. A true value turns
on the \*(L"raw deflate format\*(R", and a false value turns off the raw
deflate format. Switching this on has the side effect of automatically
switching off \*(L"gzip_format\*(R". Thus the sequence
.PP
.Vb 3
\&    $gf\->gzip_format (1);
\&    $gf\->raw (1);
\&    $gf\->raw (0);
.Ve
.PP
puts \f(CW$gf\fR in the non-raw deflate format.
.PP
\&\f(CW\*(C`raw\*(C'\fR was added in version 0.16.
.SS "level"
.IX Subsection "level"
.Vb 1
\&    $gf\->level (9);
.Ve
.PP
Set the level of compression, from 0 (no compression) to 9 (best
compression). Values outside the levels cause a warning and the level
to be set to the nearest valid value, for example a value of 100
causes the level to be set to 9. The higher the level of compression,
the more time it takes to compute. The default value is a compromise
between speed and quality of compression.
.PP
\&\f(CW\*(C`level\*(C'\fR was added in version 0.16.
.SS "mod_time"
.IX Subsection "mod_time"
.Vb 2
\&    $gf\->mod_time (time ());
\&    my $mod_time = $gf\->mod_time ();
.Ve
.PP
Set or get the file modification time in the gzip header. The
modification time is an unsigned integer which represents the number
of seconds since the Unix epoch. This only applies to \*(L"gzip_format\*(R"
compression.
.PP
\&\f(CW\*(C`mod_time\*(C'\fR was added in version 0.19.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
This section compares the performance of Gzip::Faster with
IO::Compress::Gzip / IO::Uncompress::Gunzip and
Compress::Raw::Zlib.  These results are produced by the file
\&\fIbench/benchmarks.pl\fR in the distribution.
.SS "Short text"
.IX Subsection "Short text"
This section compares the performance of Gzip::Faster and other
modules on a short piece of English text. Gzip::Faster is about five
times faster to load, seven times faster to compress, and twenty-five
times faster to uncompress than IO::Compress::Gzip and
IO::Uncompress::Gunzip. Round trips are about ten times faster with
Gzip::Faster.
.PP
Compared to Compress::Raw::Zlib, load times are about one and a
half times faster, round trips are about three times faster,
compression is about two and a half times faster, and decompression is
about six times faster.
.PP
The versions used in this test are as follows:
.PP
.Vb 4
\&    $IO::Compress::Gzip::VERSION = 2.069
\&    $IO::Uncompress::Gunzip::VERSION = 2.069
\&    $Compress::Raw::Zlib::VERSION = 2.069
\&    $Gzip::Faster::VERSION = 0.19
.Ve
.PP
The size after compression is as follows:
.PP
.Vb 3
\&    IO::Compress:Gzip size is 830 bytes.
\&    Compress::Raw::Zlib size is 830 bytes.
\&    Gzip::Faster size is 830 bytes.
.Ve
.PP
Here is a comparison of load times:
.PP
.Vb 5
\&                Rate Load IOUG Load IOCG  Load CRZ   Load GF
\&    Load IOUG 25.3/s        \-\-       \-4%      \-66%      \-77%
\&    Load IOCG 26.5/s        5%        \-\-      \-65%      \-76%
\&    Load CRZ  75.1/s      197%      184%        \-\-      \-31%
\&    Load GF    109/s      330%      311%       45%        \-\-
.Ve
.PP
Here is a comparison of a round-trip:
.PP
.Vb 4
\&                           Rate IO::Compress::Gzip Compress::Raw::Zlib  Gzip::Faster
\&    IO::Compress::Gzip   1309/s                 \-\-                \-66%          \-90%
\&    Compress::Raw::Zlib  3888/s               197%                  \-\-          \-70%
\&    Gzip::Faster        12929/s               888%                233%            \-\-
.Ve
.PP
Here is a comparison of gzip (compression) only:
.PP
.Vb 4
\&                                    Rate IO::Compress::Gzip Compress::Raw::Zlib::Deflate Gzip::Faster
\&    IO::Compress::Gzip            2567/s                 \-\-                         \-60%         \-86%
\&    Compress::Raw::Zlib::Deflate  6491/s               153%                           \-\-         \-65%
\&    Gzip::Faster                 18338/s               614%                         183%           \-\-
.Ve
.PP
Here is a comparison of gunzip (decompression) only:
.PP
.Vb 4
\&                                    Rate IO::Uncompress::Gunzip Compress::Raw::Zlib::Inflate Gzip::Faster
\&    IO::Uncompress::Gunzip        2818/s                     \-\-                         \-74%         \-96%
\&    Compress::Raw::Zlib::Inflate 10997/s                   290%                           \-\-         \-84%
\&    Gzip::Faster                 69565/s                  2368%                         533%           \-\-
.Ve
.SS "Long text"
.IX Subsection "Long text"
This section compares the compression on a 2.2 megabyte file of
Chinese text, which is the Project Gutenberg version of Journey to the
West, <http://www.gutenberg.org/files/23962/23962\-0.txt>, with the
header and footer text removed.
.PP
The versions used in this test are as above.
.PP
The sizes are as follows:
.PP
.Vb 3
\&    IO::Compress:Gzip size is 995387 bytes.
\&    Compress::Raw::Zlib size is 995387 bytes.
\&    Gzip::Faster size is 995823 bytes.
.Ve
.PP
Note that the size of the file compressed with the command-line gzip,
with the default compression, is identical to the size with
Gzip::Faster::gzip, except for the 12 bytes in the file version used
to store the file name:
.PP
.Vb 3
\&    $ gzip \-\-keep chinese.txt
\&    $ ls \-l chinese.txt.gz 
\&    \-rw\-r\-\-r\-\-  1 ben  ben  995835 Oct 20 18:52 chinese.txt.gz
.Ve
.PP
Here is a comparison of a round-trip:
.PP
.Vb 4
\&                          Rate IO::Compress::Gzip Compress::Raw::Zlib   Gzip::Faster
\&    IO::Compress::Gzip  4.43/s                 \-\-                 \-3%            \-8%
\&    Compress::Raw::Zlib 4.57/s                 3%                  \-\-            \-5%
\&    Gzip::Faster        4.81/s                 9%                  5%             \-\-
.Ve
.PP
Here is a comparison of gzip (compression) only:
.PP
.Vb 4
\&                                   Rate IO::Compress::Gzip Compress::Raw::Zlib::Deflate Gzip::Faster
\&    IO::Compress::Gzip           5.04/s                 \-\-                           0%          \-6%
\&    Compress::Raw::Zlib::Deflate 5.04/s                 0%                           \-\-          \-6%
\&    Gzip::Faster                 5.36/s                 6%                           6%           \-\-
.Ve
.PP
Here is a comparison of gunzip (decompression) only:
.PP
.Vb 4
\&                                   Rate IO::Uncompress::Gunzip Compress::Raw::Zlib::Inflate Gzip::Faster
\&    IO::Uncompress::Gunzip       36.8/s                     \-\-                         \-18%         \-20%
\&    Compress::Raw::Zlib::Inflate 45.1/s                    23%                           \-\-          \-1%
\&    Gzip::Faster                 45.7/s                    24%                           1%           \-\-
.Ve
.PP
For longer files, Gzip::Faster is not much faster. The underlying
library's speed is the main factor.
.SH "BUGS"
.IX Header "BUGS"
The module doesn't check whether the input of \*(L"gzip\*(R" is already
gzipped, and it doesn't check whether the compression was
effective. That is, it doesn't check whether the output of \*(L"gzip\*(R" is
actually smaller than the input.
.PP
In \*(L"copy_perl_flags\*(R", only the utf8 flag is implemented. Possible
other things which could be implemented are the read-only and the
taint flags.
.SS "Browser bugs and Gzip::Faster"
.IX Subsection "Browser bugs and Gzip::Faster"
Some web browsers have bugs which may affect users of this module.
.PP
Using \*(L"copy_perl_flags\*(R" with utf8\-encoded text trips a browser bug
in the Firefox web browser where it produces a content encoding error
message.
.PP
Using deflate rather than gzip compression trips browser bugs in older
versions of Internet Explorer, which mistakenly say they can handle
the deflate format, but in fact can only handle gzip format.
.SH "EXPORTS"
.IX Header "EXPORTS"
The module exports \*(L"gzip\*(R", \*(L"gunzip\*(R", \*(L"gzip_file\*(R",
\&\*(L"gunzip_file\*(R", and \*(L"gzip_to_file\*(R" by default. You can switch this
blanket exporting off with
.PP
.Vb 1
\&    use Gzip::Faster ();
.Ve
.PP
or
.PP
.Vb 1
\&    use Gzip::Faster \*(Aqgunzip\*(Aq;
.Ve
.PP
whereby you only get \f(CW\*(C`gunzip\*(C'\fR and not the other functions
exported. The functions \*(L"inflate\*(R", \*(L"deflate\*(R", \*(L"inflate_raw\*(R" and
\&\*(L"deflate_raw\*(R" are exported on demand only. You can export all the
functions from the module using
.PP
.Vb 1
\&    use Gzip::Faster \*(Aq:all\*(Aq;
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Data input to inflate is not in libz format" 4
.IX Item "Data input to inflate is not in libz format"
(Fatal) The data given to \*(L"gunzip\*(R", \*(L"inflate\*(R", \*(L"inflate_raw\*(R", or
\&\*(L"unzip\*(R" was not in the compressed format.
.IP "Error opening '$file': $!" 4
.IX Item "Error opening '$file': $!"
(Fatal) This may be produced by \*(L"gunzip_file\*(R", \*(L"gzip_file\*(R", or
\&\*(L"gzip_to_file\*(R".
.IP "Error closing '$file': $!" 4
.IX Item "Error closing '$file': $!"
(Fatal) This may be produced by \*(L"gunzip_file\*(R", \*(L"gzip_file\*(R", or
\&\*(L"gzip_to_file\*(R".
.IP "wrong format: perl flags not copied: use \fBgzip_format\fR\|(1)" 4
.IX Item "wrong format: perl flags not copied: use gzip_format"
(Warning) The user tried to use \*(L"copy_perl_flags\*(R" together with
deflate compression, which isn't possible. Use \*(L"gzip_format\*(R" with a
true argument to allow \*(L"copy_perl_flags\*(R" to work.
.IP "wrong format: file name ignored: use \fBgzip_format\fR\|(1)" 4
.IX Item "wrong format: file name ignored: use gzip_format"
(Warning) The user tried to use \*(L"file_name\*(R" together with deflate
compression, which isn't possible. Use \*(L"gzip_format\*(R" with a true
argument to allow \*(L"file_name\*(R" to work.
.ie n .IP "Cannot set compression level to less than %d" 4
.el .IP "Cannot set compression level to less than \f(CW%d\fR" 4
.IX Item "Cannot set compression level to less than %d"
(Warning) The user used \*(L"level\*(R" with a negative value.
.ie n .IP "Cannot set compression level to more than %d" 4
.el .IP "Cannot set compression level to more than \f(CW%d\fR" 4
.IX Item "Cannot set compression level to more than %d"
(Warning) The user used \*(L"level\*(R" with a value greater than nine.
.IP "Cannot write file name to non-scalar reference" 4
.IX Item "Cannot write file name to non-scalar reference"
(Warning) The user's value for \f(CW\*(C`file_name\*(C'\fR in the optional argument
to \*(L"gunzip_file\*(R" was not a scalar reference.
.IP "Empty input" 4
.IX Item "Empty input"
(Warning) The user tried to compress or decompress the undefined value.
.IP "Attempt to (un)compress empty string" 4
.IX Item "Attempt to (un)compress empty string"
(Warning) The user tried to compress or decompress an empty string, as in
.Sp
.Vb 1
\&    my $out = inflate (\*(Aq\*(Aq);
.Ve
.PP
There are other diagnostic messages in the module to detect bugs. A
list can be obtained by running the \f(CW\*(C`parse\-diagnostics\*(C'\fR script which
comes with Parse::Diagnostics on the files \fIgzip\-faster\-perl.c\fR
and \fIlib/Gzip/Faster.pm\fR in the distribution.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Installation follows standard Perl methods. Detailed instructions can
be found in the file \fI\s-1README\s0\fR <https://fastapi.metacpan.org/source/BKB/Gzip-Faster-0.21/README> in the distribution. The
following are some extra notes for people who get stuck.
.PP
Gzip::Faster requires the compression library \*(L"zlib\*(R" (also called
\&\f(CW\*(C`libz\*(C'\fR) to be installed on your computer. The following message
printed during \f(CW\*(C`perl Makefile.PL\*(C'\fR:
.PP
.Vb 1
\&    You don\*(Aqt seem to have zlib available on your system.
.Ve
.PP
or
.PP
.Vb 1
\&    Warning (mostly harmless): No library found for \-lz
.Ve
.PP
or the following message at run-time:
.PP
.Vb 1
\&    undefined symbol: inflate
.Ve
.PP
indicate that Gzip::Faster was unable to link to \f(CW\*(C`libz\*(C'\fR.
.SS "Ubuntu Linux"
.IX Subsection "Ubuntu Linux"
On Ubuntu Linux, you may need to install \f(CW\*(C`zlib1g\-dev\*(C'\fR using the
following command:
.PP
.Vb 1
\&    sudo apt\-get install zlib1g\-dev
.Ve
.SS "Windows"
.IX Subsection "Windows"
Unfortunately at this time the module doesn't seem to install on
ActiveState Perl. You can check the current status at
<http://code.activestate.com/ppm/Gzip\-Faster/>. However, the module
seems to install without problems on Strawberry Perl, so if you cannot
install via ActiveState, you could try that instead.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SS "About gzip"
.IX Subsection "About gzip"
The gzip and deflate formats are closely related formats for
compressing information. They are used for compressing web pages to
reduce the amount of data sent, for compressing source code files, or
in applications such as \s-1MATLAB\s0 files or \s-1PNG\s0 images.
.PP
These formats are formally described by \s-1RFC 1950\s0 <https://tools.ietf.org/rfc/rfc1950.txt> (\s-1ZLIB\s0
Compressed Data Format Specification), \s-1RFC 1951\s0 <https://tools.ietf.org/rfc/rfc1951.txt> (\s-1DEFLATE\s0
Compressed Data Format Specification), and \s-1RFC 1952\s0 <https://tools.ietf.org/rfc/rfc1952.txt> (\s-1GZIP\s0 file
format specification). The library \*(L"zlib\*(R" implements the formats.
.SS "Alternatives"
.IX Subsection "Alternatives"
The following alternatives to this module may also be useful.
.IP "Command-line gzip" 4
.IX Item "Command-line gzip"
To use the command line utility \f(CW\*(C`gzip\*(C'\fR, use
.Sp
.Vb 1
\&    system ("gzip file");
.Ve
.Sp
or put the command in backquotes, like \f(CW\*(C`\`gzip file\`\*(C'\fR.
.IP "mod_deflate and mod_gzip" 4
.IX Item "mod_deflate and mod_gzip"
These are Apache web server modules which compress web outputs
immediately after you produce them, and before sending to the user.
.IP "PerlIO::gzip" 4
.IX Item "PerlIO::gzip"
This is a Perl extension to provide a PerlIO layer to
gzip/gunzip. That means you can just add \f(CW\*(C`:gzip\*(C'\fR when you open a file
to read or write compressed files:
.Sp
.Vb 1
\&    open my $in, "<:gzip", \*(Aqfile.gz\*(Aq
\&
\&    open my $out, ">:gzip", \*(Aqfile.gz\*(Aq
.Ve
.Sp
and you never have to deal with the gzip format.
.IP "IO::Zlib" 4
.IX Item "IO::Zlib"
.PD 0
.IP "Compress::Zlib" 4
.IX Item "Compress::Zlib"
.IP "Compress::Raw::Zlib" 4
.IX Item "Compress::Raw::Zlib"
.IP "CGI::Compress::Gzip" 4
.IX Item "CGI::Compress::Gzip"
.IP "IO::Compress::Gzip and IO::Uncompress::Gunzip" 4
.IX Item "IO::Compress::Gzip and IO::Uncompress::Gunzip"
.IP "Gzip::RandomAccess \- extract arbitrary bits of a gzip stream" 4
.IX Item "Gzip::RandomAccess - extract arbitrary bits of a gzip stream"
.IP "Compress::Zopfli" 4
.IX Item "Compress::Zopfli"
.PD
This is a compress-only library by Google <https://www.google.com>
for a gzip/deflate format compression.
.SH "EXTENDED EXAMPLES"
.IX Header "EXTENDED EXAMPLES"
This section gives some extended examples of the use of this module.
.IP "\s-1CGI\s0 output" 4
.IX Item "CGI output"
Compressing \s-1CGI\s0 output with Perl and
Gzip::Faster <https://www.lemoda.net/cgi/perl-gzip-faster-cgi/index.html>
demonstrates how to use Gzip::Faster to compress the output of a web
program.
.IP "Get compressed web pages" 4
.IX Item "Get compressed web pages"
Requesting compressed content from a web server with
LWP::UserAgent <https://www.lemoda.net/compression/lwp-use-gzip/index.html>
demonstrates how to use Gzip::Faster with LWP::UserAgent when
requesting compressed content.
.IP "View the image data of a \s-1PNG\s0" 4
.IX Item "View the image data of a PNG"
The following example demonstrates using \*(L"inflate\*(R" to view the image
data within a \s-1PNG\s0 image. See \*(L"\s-1ACKNOWLEDGEMENTS\*(R"\s0 for credit.
.Sp
.Vb 10
\&    use File::Slurper \*(Aqread_binary\*(Aq;
\&    use FindBin \*(Aq$Bin\*(Aq;
\&    use Gzip::Faster \*(Aqinflate\*(Aq;
\&    my $pngfile = "$Bin/larry\-wall.png";
\&    my $pngdata = read_binary ($pngfile);
\&    if ($pngdata !~ /IHDR(.{13})/) {
\&        die "No header";
\&    }
\&    my ($height, $width, $bits) = unpack ("NNCCCCC", $1);
\&    if ($pngdata !~ /(....)IDAT(.*)$/s) {
\&        die "No image data";
\&    }
\&    my $length = unpack ("N", $1);
\&    my $data = substr ($2, 0, $length);
\&    my $idat = inflate ($data);
\&    for my $y (0..$height \- 1) {
\&        my $row = substr ($idat, $y * ($width + 1), ($y + 1) * ($width + 1));
\&        for my $x (1..$width \- 1) {
\&            my $pixel = substr ($row, $x, $x + 1);
\&            if (ord ($pixel) < 128) {
\&                print "#";
\&                next;
\&            }
\&            print " ";
\&        }
\&        print "\en";
\&    }
.Ve
.Sp
produces output
.Sp
.Vb 10
\&               ######              
\&             #########             
\&           #############           
\&          ###############          
\&          ################         
\&         ##################        
\&         ########   ########       
\&        #######      #######       
\&        ####          ######       
\&        ###           ######       
\&        ###           #######      
\&       ########    ##########      
\&       ####  ###    #  ######      
\&       #### # ##   #  ######       
\&       ####       #     ###        
\&        ###       #    ####        
\&                  ##   ###         
\&                  ##   ###         
\&              ######## ###         
\&             ##############        
\&            ##### #########        
\&            ## ## ##########       
\&             #   ##  ########      
\&             #       ##########    
\&          #####    ########### ### 
\&        ######     ################
\&      #########  ######  ##########
\&     ##########    ###   # ########
\&    # # #######    #     ##########
\&    #  ###### #          ##########
.Ve
.Sp
(This example is included as \fIinflate.pl\fR <https://fastapi.metacpan.org/source/BKB/Gzip-Faster-0.21/examples/inflate.pl> in the distribution.)
.SH "GLOSSARY"
.IX Header "GLOSSARY"
This section describes some of the terminology of the Gzip compression
system.
.IP "deflate format" 4
.IX Item "deflate format"
The deflate format is the same as the \*(L"gzip format\*(R" except that it
does not contain the header with the additional information such as
the file name and modification time. The deflate format may or may not
include a checksum. If it does not include the checksum, it is the
\&\*(L"raw deflate format\*(R". The deflate format is the format used within
\&\s-1PNG\s0 images, for example.
.IP "gzip format" 4
.IX Item "gzip format"
The gzip format is the same as the \*(L"deflate format\*(R" except that it
includes a header which may contain such things as a file name or a
modification time. The gzip format is the one used by the command-line
utility gzip in such things as .tar.gz files.
.IP "raw deflate format" 4
.IX Item "raw deflate format"
The raw deflate format is a form of the \*(L"deflate format\*(R" without an
Adler\-32 checksum. (The terminology \*(L"raw deflate\*(R" for this format is
from the zlib manual <http://zlib.net/manual.html> and does not
appear in the RFCs.)
.IP "zlib" 4
.IX Item "zlib"
zlib is the implementation of the gzip and deflate algorithms.  zlib
is necessary to install Gzip::Faster. It is described at
<http://zlib.net>.
.SH "HISTORY"
.IX Header "HISTORY"
This module started as an experimental benchmark against
IO::Compress::Gzip when profiling revealed that some programs were
spending the majority of their time in IO::Compress::Gzip. Since I
(Ben Bullock) knew that zlib was fast, I was surprised by the time the
Perl code was taking. I wrote Gzip::Faster to test IO::Compress::Gzip
against a simplistic gzip wrapper. I released the module to \s-1CPAN\s0
because the results were very striking. See \*(L"\s-1PERFORMANCE\*(R"\s0 above for
details.
.PP
Gzip::Faster's ancestor is the example program \f(CW\*(C`zpipe\*(C'\fR supplied with
zlib. See <http://zlib.net/zpipe.c>. Gzip::Faster is \f(CW\*(C`zpipe\*(C'\fR reading
to and and writing from Perl scalars.
.PP
Version 0.16 added \*(L"deflate\*(R" and related functions and the
object-oriented functions.
.PP
Version 0.18 added the ability to set and get file names to the
g*zip*file functions, and version 0.19 added modification times.
.PP
Version 0.21 added warnings upon input of empty strings to \*(L"gzip\*(R",
\&\*(L"gunzip\*(R", and friends.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
zgrim reported an important bug related to zlib.
.PP
Aristotle Pagaltzis contributed the benchmarking code for
Compress::Raw::Zlib.
.PP
The tests in \fIt/png.t\fR and the example \*(L"View the image data of a
\&\s-1PNG\*(R"\s0 use material taken from Image::PNG::Write::BW by Andrea Nall
(<\s-1ANALL\s0>).
.SH "AUTHOR"
.IX Header "AUTHOR"
Ben Bullock, <bkb@cpan.org>
.SH "COPYRIGHT & LICENCE"
.IX Header "COPYRIGHT & LICENCE"
This package and associated files are copyright (C) 
2014\-2017
Ben Bullock.
.PP
You can use, copy, modify and redistribute this package and associated
files under the Perl Artistic Licence or the \s-1GNU\s0 General Public
Licence.
